# interface.py (interfaz integrada con gráfico embebido en Tkinter)import tkinter as tkfrom tkinter import filedialog, ttk, messageboxfrom airSpace import AirSpaceimport matplotlib.pyplot as pltfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggfrom math import sqrtfrom collections import dequefrom queue import PriorityQueueclass AirSpaceGUI:   def __init__(self, master):       self.master = master       self.master.title("Visualizador de Espacio Aéreo")       self.airspace = AirSpace()       self.figure, self.ax = plt.subplots(figsize=(8, 6))       self.canvas = FigureCanvasTkAgg(self.figure, master=self.master)       self.canvas.get_tk_widget().grid(row=6, column=0, columnspan=3)       self.canvas.mpl_connect('button_press_event', self.on_click)       ttk.Button(master, text="Cargar ficheros Catalunya", command=self.load_cat_data).grid(row=0, column=0, padx=5, pady=5)       ttk.Button(master, text="Mostrar puntos y segmentos", command=self.plot_graph).grid(row=0, column=1, padx=5, pady=5)       ttk.Label(master, text="Nombre del punto:").grid(row=1, column=0, sticky="e")       self.point_entry = ttk.Entry(master)       self.point_entry.grid(row=1, column=1, sticky="w")       ttk.Button(master, text="Mostrar vecinos", command=self.plot_neighbors).grid(row=1, column=2, padx=5, pady=5)       ttk.Button(master, text="Mostrar alcanzabilidad", command=self.plot_reachability).grid(row=2, column=2, padx=5, pady=5)       ttk.Label(master, text="Origen:").grid(row=3, column=0, sticky="e")       self.origin_entry = ttk.Entry(master)       self.origin_entry.grid(row=3, column=1, sticky="w")       ttk.Label(master, text="Destino:").grid(row=4, column=0, sticky="e")       self.dest_entry = ttk.Entry(master)       self.dest_entry.grid(row=4, column=1, sticky="w")       ttk.Button(master, text="Camino más corto", command=self.plot_shortest_path).grid(row=4, column=2, padx=5, pady=5)       self.info_label = ttk.Label(master, text="")       self.info_label.grid(row=5, column=0, columnspan=3)   def load_cat_data(self):       self.airspace.load_all("Cat_nav.txt", "Cat_seg.txt", "Cat_aer.txt")       self.info_label.config(text=f"Datos cargados: {len(self.airspace.nav_points)} puntos, {len(self.airspace.nav_segments)} segmentos, {len(self.airspace.nav_airports)} aeropuertos")       self.plot_graph()   def plot_graph(self):       self.ax.clear()       x = [p.longitude for p in self.airspace.nav_points]       y = [p.latitude for p in self.airspace.nav_points]       self.ax.scatter(x, y, s=5, color='gray', label='NavPoints')       for s in self.airspace.nav_segments:           p1 = self.airspace.get_point_by_number(s.origin_number)           p2 = self.airspace.get_point_by_number(s.destination_number)           if p1 and p2:               self.ax.plot([p1.longitude, p2.longitude], [p1.latitude, p2.latitude], 'k-', linewidth=0.5)       for airport in self.airspace.nav_airports:           if airport.sids:               sid = airport.sids[0]               self.ax.scatter(sid.longitude, sid.latitude, s=50, color='red')               self.ax.text(sid.longitude, sid.latitude, airport.name, fontsize=8, color='red')       self.ax.set_title("Espacio Aéreo Catalunya con Aeropuertos")       self.ax.set_xlabel("Longitud")       self.ax.set_ylabel("Latitud")       self.ax.grid(True)       self.ax.legend()       self.canvas.draw()   def on_click(self, event):       if event.inaxes:           clicked_lon = event.xdata           clicked_lat = event.ydata           closest = min(self.airspace.nav_points,                         key=lambda p: self.euclidean_distance_coords(clicked_lat, clicked_lon, p.latitude,                                                                      p.longitude))           self.ax.plot(clicked_lon, clicked_lat, marker='x', color='purple', markersize=10)           self.canvas.draw_idle()           self.point_entry.delete(0, tk.END)           self.point_entry.insert(0, closest.name)           texto = (f"¿Usar '{closest.name}' como:\n"                    f"Sí → Origen\n"                    f"No → Destino\n"                    f"Cancelar para ignorar.")           respuesta = messagebox.askyesnocancel("Seleccionar punto", texto)           if respuesta is True:               self.origin_entry.delete(0, tk.END)               self.origin_entry.insert(0, closest.name)               self.info_label.config(text=f"Origen seleccionado: {closest.name}")           elif respuesta is False:               self.dest_entry.delete(0, tk.END)               self.dest_entry.insert(0, closest.name)               self.info_label.config(text=f"Destino seleccionado: {closest.name}")           else:               self.info_label.config(text="Selección cancelada")   def plot_neighbors(self):       name = self.point_entry.get().strip()       point = self.airspace.get_point_by_name(name)       if not point:           self.info_label.config(text=f"No se ha encontrado el punto {name}")           return       self.plot_graph()       for s in self.airspace.nav_segments:           if s.origin_number == point.number:               neighbor = self.airspace.get_point_by_number(s.destination_number)               if neighbor:                   self.ax.plot([point.longitude, neighbor.longitude], [point.latitude, neighbor.latitude], 'r-')                   self.ax.scatter(neighbor.longitude, neighbor.latitude, color='green', s=20)       self.ax.scatter(point.longitude, point.latitude, color='blue', s=40)       self.canvas.draw()   def plot_reachability(self):       name = self.point_entry.get().strip()       origin = self.airspace.get_point_by_name(name)       if not origin:           self.info_label.config(text=f"Punto {name} no encontrado")           return       reached = set()       queue = deque([origin])       while queue:           current = queue.popleft()           reached.add(current.number)           for s in self.airspace.nav_segments:               if s.origin_number == current.number:                   neighbor = self.airspace.get_point_by_number(s.destination_number)                   if neighbor and neighbor.number not in reached:                       queue.append(neighbor)       self.plot_graph()       for p in self.airspace.nav_points:           color = 'green' if p.number in reached else 'gray'           self.ax.scatter(p.longitude, p.latitude, s=5, color=color)       self.ax.scatter(origin.longitude, origin.latitude, s=40, color='blue', label='Origen')       self.canvas.draw()   def plot_shortest_path(self):       origin_name = self.origin_entry.get().strip()       dest_name = self.dest_entry.get().strip()       origin = self.airspace.get_point_by_name(origin_name)       dest = self.airspace.get_point_by_name(dest_name)       if not origin or not dest:           self.info_label.config(text="Origen o destino no encontrado")           return       open_set = PriorityQueue()       open_set.put((0, [origin]))       visited = set()       while not open_set.empty():           _, path = open_set.get()           current = path[-1]           if current.number == dest.number:               self.draw_path(path)               return           if current.number in visited:               continue           visited.add(current.number)           for s in self.airspace.nav_segments:               if s.origin_number == current.number:                   neighbor = self.airspace.get_point_by_number(s.destination_number)                   if neighbor and neighbor.number not in visited:                       new_path = list(path)                       new_path.append(neighbor)                       cost = self.path_cost(new_path) + self.euclidean_distance(neighbor, dest)                       open_set.put((cost, new_path))       self.info_label.config(text="No se encontró camino")   def draw_path(self, path):       self.plot_graph()       for i in range(len(path) - 1):           p1, p2 = path[i], path[i+1]           self.ax.plot([p1.longitude, p2.longitude], [p1.latitude, p2.latitude], 'b-', linewidth=2)       for p in path:           self.ax.scatter(p.longitude, p.latitude, color='orange', s=30)       self.canvas.draw()   def path_cost(self, path):       total = 0       for i in range(len(path) - 1):           for seg in self.airspace.nav_segments:               if seg.origin_number == path[i].number and seg.destination_number == path[i+1].number:                   total += seg.distance                   break       return total   def euclidean_distance(self, p1, p2):       return sqrt((p1.latitude - p2.latitude)**2 + (p1.longitude - p2.longitude)**2)   def euclidean_distance_coords(self, lat1, lon1, lat2, lon2):       return sqrt((lat1 - lat2)**2 + (lon1 - lon2)**2)if __name__ == "__main__":   root = tk.Tk()   app = AirSpaceGUI(root)   root.mainloop()